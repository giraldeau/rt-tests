#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Do not import nothing fancy, this is inteded to run on an embedded target

from subprocess import Popen, PIPE, check_output
import signal
import os
import re
import time
import sys
import json

class BasicCommand(object):
    
    def setup_arguments(self, parser):
        pass
    
    def run(self, args):
        print(args)
        
    def cleanup(self):
        pass

class ExperimentCommand(BasicCommand):

    defaults = {
        "cyclictest": {
            "threads": 1,
            "mlockall": None,
            "distance": 0,
            "duration": 1,
            "histogram": 300,
            "interval": 1000,
            "affinity": 3,
            "notrace": None,
            "quiet": None,
            "priority": 99,
            "policy": "fifo",
        }
    }

    experiments = {
        "isolcpu": {
            "prog": "cyclictest",
            "opts": {
                "affinity": "2-3",
                "threads": 2,
                "relative": None,
                "interval": 1,
            },
        },
        "ftrace": {
            "prog": "cyclictest",
            "opts": {
                "affinity": "2-3",
                "threads": 2,
                "relative": None,
                "interval": 1,
            },
        },
    }

    # FIXME: uses parameters instead of hardcoded values
    workloads = {
        "mix": {
            "prog": "stress",
            "opts": {
                "cpu": 8,
                "io": 8,
                "vm": 2,
                "vm-bytes": "128M",
                "hdd-bytes": "4096B",
                "hdd": 8,
            },
        },
    }

    def __init__(self):
        self.choices = ["all"] + self.experiments.keys()
        self.exp = None
        self.wkl = None
        self._tried_modprobe_configs = False

    def _merge_dict(self, d1, d2):
        d = {}
        for k1, v1 in d1.items():
            d[k1] = v1
        for k2, v2 in d2.items():
            d[k2] = v2
        return d 

    def _build_command(self, prog, opts):
        cmd = [prog]
        for opt, val in opts.items():
            cmd.append("--" + opt)
            if val is not None:
                cmd.append(str(val))
        return cmd
    
    def _expand_commands(self, exp, defaults):
        cmds = {}
        for name, params in exp.items():
            prog = params["prog"]
            d1 = self.defaults.get(prog, {})
            d2 = params.get("opts", {})
            opts = self._merge_dict(d1, d2)
            cmd = self._build_command(prog, opts)
            cmds[name] = cmd
        return cmds
    
    def setup_arguments(self, parser):
        parser.add_argument("experiment", nargs='?',
            choices=self.choices,
            default=self.choices[0])
        parser.add_argument("--list-experiments", action="store_true", default=False)
        #parser.add_argument("--dry-run", action="store_true", default=False)
        parser.add_argument("--duration", type=float, default=1)
        parser.add_argument("--machine-info", action="store_true", default=False)
        parser.add_argument("--output", type=str, default="/tmp/go-rttest/")

    def terminate_task_group(self, handle):
        if handle and handle.poll() is None:
            os.killpg(os.getpgid(handle.pid), signal.SIGTERM)
            handle.wait()

    def terminate_task(self, handle):
        if handle and handle.poll() is None:
            handle.terminate()

    def run(self, args):
        if args.list_experiments:
            print("Experiments: " + " ".join(self.choices))
            return
        
        if args.machine_info:
            info = self.machine_info()
            with open("machine.json", "w") as f:
                f.write(json.dumps(info, indent=2, sort_keys=True))
            sys.exit(0)
        
        exp_cmds = self._expand_commands(self.experiments, self.defaults)
        wkl_cmds = self._expand_commands(self.workloads, self.defaults)
        
        if args.verbose:
            print(exp_cmds)
            print(wkl_cmds)
        
        # create output directory
        base_dir = args.output
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        
        for wkl_name, wkl_cmd in wkl_cmds.items():
            for exp_name, exp_cmd in exp_cmds.items():
                # start the workload
                self.wkl = Popen(wkl_cmd, preexec_fn=os.setsid, stdout=PIPE, stderr=PIPE)
                time.sleep(1)
                
                # run the main program for the specified amount of time
                self.exp = Popen(exp_cmd, stdout=PIPE, stderr=PIPE)
                time.sleep(args.duration)
                self.terminate_task(self.exp)
                
                # terminate the workload
                self.terminate_task_group(self.wkl)

                out, unused_err = self.exp.communicate()
                
                out_path = os.path.join(base_dir, exp_name, wkl_name)
                if not os.path.exists(out_path):
                    os.makedirs(out_path)
                out_file = os.path.join(out_path, exp_cmd[0] + ".stdout")
                with open(out_file, "w") as f:
                    f.write(out)
                    
                info = self.machine_info()
                info["experiment"] = exp_name
                info["workload"] = wkl_name
                out_file = os.path.join(out_path, machine + ".info")
                with open() as f:
                    pass
                

    def cleanup(self):
        self.terminate_task(self.exp)
        self.terminate_task_group(self.wkl)
    
    def parse_kconfig(self, info, file):
        r1 = re.compile("# (?P<label>CONFIG_[A-Z0-9_]+) is not set")
        r2 = re.compile("(?P<label>CONFIG_[A-Z0-9_]+)=(?P<value>.*)")
        r = [r1, r2]
        for line in file.readlines():
            for rx in r:
                m = rx.match(line)
                if m:
                    d = m.groupdict()
                    label = d.get("label")
                    value = d.get("value", None)
                    info[label] = value
                    break
    
    def parse_cpuinfo(self, info, file):
        rx = re.compile("(?P<label>([a-zA-Z0-9_]+([ ]+[a-zA-Z0-9_]+)?))\s*:\s*(?P<value>.*)")
        for line in file.readlines():
            m = rx.match(line)
            if m:
                l = m.group("label")
                v = m.group("value")
                info[l] = v

    def parse_sysctl(self, info, output):
        rx = re.compile("(?P<label>[a-zA-Z0-9_.]+)\s*=\s*(?P<value>.*)")
        for line in output.splitlines():
            m = rx.match(line)
            if m:
                l = m.group("label")
                v = m.group("value")
                info[l] = v

    
    def machine_info(self):
        info = {}
        
        # kernel config
        kconfig_path = "/proc/config.gz"
        if not os.path.isfile(kconfig_path) and \
            not self._tried_modprobe_configs:
            p = Popen(["modprobe", "configs"], stderr=PIPE)
            p.wait()
            self._tried_modprobe_configs = True
        
        if os.path.isfile(kconfig_path):
            output = check_output(["zcat", kconfig_path])
            self.parse_kconfig(info, output)
        else:
            uname = check_output(["uname", "-r"])
            kconfig_path = "/boot/config-%s" % uname.strip()
            if os.path.isfile(kconfig_path):
                with open(kconfig_path, "r") as f:
                    self.parse_kconfig(info, f)
        
        cpuinfo = "/proc/cpuinfo"
        if os.path.isfile(cpuinfo):
            with open(cpuinfo, "r") as f:
                self.parse_cpuinfo(info, f)
        
        
        bootid = "/proc/sys/kernel/random/boot_id"
        if os.path.isfile(bootid):
            with open(bootid, "r") as f:
                info["bootid"] = f.read().strip()
        
        output = check_output(["sysctl", "--all"], stderr=PIPE)
        self.parse_sysctl(info, output)
        
        cmdline = "/proc/cmdline"
        if os.path.isfile(cmdline):
            with open(cmdline, "r") as f:
                info["cmdline"] = f.read().strip()
        
        return info

class CPUGovernor(object):
    def __init__(self):
        self.state = {}
        self.num_cpus = None

    def get_num_cpus(self):
        if not self.num_cpus:
            low = high = 0
            with open("/sys/devices/system/cpu/online", "r") as f:
                low, high = f.read().strip().split("-")
                self.num_cpus = int(high)
        return self.num_cpus

    def _set_governor(self, cpu, name):
        cpufile = "/sys/devices/system/cpu/cpu{}/cpufreq/scaling_governor".format(cpu)
        print(cpufile + " " + name)
        temp = "powersave"
        with open(cpufile, "r") as governor:
            temp = governor.read().strip()
            
        with open(cpufile, "w") as governor:
            governor.write(name)
        return temp

    def set_governor(self, name):
        cpus = self.get_num_cpus()
        for cpu in range(cpus + 1):
            self.state[cpu] = self._set_governor(cpu, name)
            
    def restore(self):
        print(self.state)
        for cpu, gov in self.state.items():
            self._set_governor(cpu, gov)

if __name__=="__main__":

    commands = {
        "experiments": ExperimentCommand()
    }

    import argparse
    
    parser = argparse.ArgumentParser()

    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        action="store_true")

    subparsers = parser.add_subparsers(help='sub-command help', dest="cmd")
    for name, command in commands.items():
        sub = subparsers.add_parser(name)
        command.setup_arguments(sub)

    args = parser.parse_args()

    obj = commands[args.cmd]
    
    gov = CPUGovernor()
    
    try:
        gov.set_governor("performance")
        obj.run(args)
    except KeyboardInterrupt:
        print("exiting...")
    finally:
        obj.cleanup()
        gov.restore()

