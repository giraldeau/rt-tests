#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Do not import nothing fancy, this is inteded to run on an embedded target

from subprocess import Popen, PIPE, check_output, check_call
import signal
import os
import re
import time
import sys
import json
import copy

class BasicCommand(object):
    
    def setup_arguments(self, parser):
        pass
    
    def run(self, args):
        print(args)
        
    def cleanup(self):
        pass

class ExperimentCommand(BasicCommand):

    defaults = {
        "cyclictest": {
            "threads": 1,
            "mlockall": None,
            "distance": 0,
            "duration": 1,
            "histogram": 300,
            "interval": 1000,
            "affinity": 3,
            "notrace": None,
            "quiet": None,
            "priority": 99,
            "policy": "fifo",
        }
    }

    # Seems the relative option with too short interval overflows
    # the statistics computation
    experiments = {
        "isolcpu": {
            "prog": "cyclictest",
            "opts": {
                "affinity": "3,0",
                "threads": 2,
                "interval": 1000,
                "distance": 0,
            },
        },
    }

    # FIXME: uses parameters instead of hardcoded values
    workloads = {
        "mix": {
            "prog": "stress",
            "opts": {
                "cpu": 8,
                "io": 8,
                "vm": 2,
                "vm-bytes": "128M",
                "hdd-bytes": "4096B",
                "hdd": 8,
            },
        },
        "net": {
            "prog": "netperf",
            "spawn": 10,
            "opts": {
               "l": 0,
               "H": "berta.dorsal.polymtl.ca",
            }
        }
    }

    def __init__(self):
        self.choices = ["all"] + self.experiments.keys()
        self.exp = None
        self.wkl = []
        self._tried_modprobe_configs = False
        self.gov = CPUGovernor()

    def _merge_dict(self, d1, d2):
        d = {}
        for k1, v1 in d1.items():
            d[k1] = v1
        for k2, v2 in d2.items():
            d[k2] = v2
        return d 

    def _build_command(self, prog, opts):
        cmd = [prog]
        for opt, val in opts.items():
            if len(opt) == 1:
                cmd.append("-" + opt)
            else:
                cmd.append("--" + opt)
            if val is not None:
                cmd.append(str(val))
        return cmd
    
    def _expand_commands(self, exp, defaults):
        cmds = {}
        for name, params in exp.items():
            prog = params["prog"]
            d1 = self.defaults.get(prog, {})
            d2 = params.get("opts", {})
            opts = self._merge_dict(d1, d2)
            cmd = self._build_command(prog, opts)
            cmds[name] = cmd
        return cmds
    
    def setup_arguments(self, parser):
        parser.add_argument("experiment", nargs='?',
            choices=self.choices,
            default=self.choices[0])
        parser.add_argument("--list-experiments", action="store_true", default=False)
        #parser.add_argument("--dry-run", action="store_true", default=False)
        parser.add_argument("--duration", type=float, default=1)
        parser.add_argument("--machine-info", action="store_true", default=False)
        parser.add_argument("--disable-frequency-scaling", action="store_true", default=False)
        parser.add_argument("--output", type=str, default="/tmp/go-rttest/")

    def terminate_task_group(self, handle):
        if isinstance(handle, list):
           for h in handle:
               self.terminate_task_group(h)
           del handle[:]
           return
        if handle and handle.poll() is None:
            os.killpg(os.getpgid(handle.pid), signal.SIGTERM)
            handle.wait()

    def terminate_task(self, handle):
        if handle and handle.poll() is None:
            handle.terminate()

    def check_task(self, task):
        ret = task.poll()
        if ret and ret is not 0:
            out, err = task.communicate()
            raise RuntimeError("Command failed (ret={}) {}\n{}\n{}".format(ret, " ".join(exp_cmd), out, err))

    def run(self, args):
        if args.list_experiments:
            print("Experiments: " + " ".join(self.choices))
            return
        
        if args.machine_info:
            info = self.machine_info()
            with open("machine.json", "w") as f:
                f.write(json.dumps(info, indent=2, sort_keys=True))
            return
        
        if args.disable_frequency_scaling:
            self.gov.set_governor("performance")
        
        # set runtime limits for rt task
        check_call(["sysctl", "-w", "kernel.sched_rt_runtime_us=-1"])
        
        exp_cmds = self._expand_commands(self.experiments, self.defaults)
        wkl_cmds = self._expand_commands(self.workloads, self.defaults)
        
        if args.verbose:
            print(exp_cmds)
            print(wkl_cmds)
        
        # create output directory
        base_dir = args.output
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        
        for wkl_name, wkl_cmd in wkl_cmds.items():
            for exp_name, exp_cmd in exp_cmds.items():
                # start the workload

                spawn = self.workloads[wkl_name].get("spawn", 1)
                for i in range(spawn):
                    if args.verbose:
                        print("Exec:" + " ".join(wkl_cmd))
                    wkl = Popen(wkl_cmd, preexec_fn=os.setsid, stdout=PIPE, stderr=PIPE)
                    self.wkl.append(wkl)
                # workload warm-up
                time.sleep(1)
                
                # run the main program for the specified amount of time
                if args.verbose:
                    print("Exec:" + " ".join(exp_cmd))
                self.exp = Popen(exp_cmd, stdout=PIPE, stderr=PIPE)
                tstart = time.time()
                while((time.time() - tstart) < args.duration):
                    # FIXME: check if the workload is still running
                    self.check_task(self.exp)
                    for task in self.wkl:
                        self.check_task(task)

                # terminate the workload
                self.terminate_task(self.exp)
                self.terminate_task_group(self.wkl)

                out, unused_err = self.exp.communicate()
                                    
                info = self.machine_info()
                
                self.parse_cyclictest_hist(info, out)
                info["experiment"] = exp_name
                info["workload"] = wkl_name
                info["now"] = time.time()

                now = time.strftime("%Y%m%d%H%M%S")
                result_file = "{}_{}_{}.json".format(now, exp_name, wkl_name)
                out_path = os.path.join(base_dir, result_file)

                with open(out_path, "w") as f:
                    f.write(json.dumps(info, indent=2, sort_keys=True))
                
    def cleanup(self):
        self.terminate_task(self.exp)
        self.terminate_task_group(self.wkl)
        self.gov.restore()
    
    def parse_cyclictest_hist(self, info, out):
        r1 = re.compile("(?P<bucket>[0-9]+)\s+((?P<value>[0-9]+)\s*)+")    
        item = {
            "histogram": [],
            "total": 0,
            "min": 0,
            "max": 0,
            "avg": 0,
            "overflows": 0,
        }
        
        data = []
        
        labels = {
            "total": "# Total:",
            "min": "# Min Latencies:",
            "max": "# Max Latencies:",
            "avg": "# Avg Latencies:",
            "overflows": "# Histogram Overflows:",
        }
        
        for line in out.splitlines():
            m = r1.match(line)
            if m:
                col = len(m.groups())
                # initialize the data
                if len(data) == 0:
                    for c in range(col - 1):
                        data.append(copy.deepcopy(item))
                for c in range(1, col):
                    data[c - 1]["histogram"].append(int(m.groups()[c]))
            else:
                for name, head in labels.items():
                    if line.startswith(head):
                        values = line[len(head):].strip().split()
                        for i, v in enumerate(values):
                            data[i][name] = int(v)
        info["results"] = data
    
    def parse_kconfig(self, info, data):
        r1 = re.compile("# (?P<label>CONFIG_[A-Z0-9_]+) is not set")
        r2 = re.compile("(?P<label>CONFIG_[A-Z0-9_]+)=(?P<value>.*)")
        r = [r1, r2]
        for line in data.splitlines():
            for rx in r:
                m = rx.match(line)
                if m:
                    d = m.groupdict()
                    label = d.get("label")
                    value = d.get("value", None)
                    info[label] = value
                    break
    
    def parse_cpuinfo(self, info, data):
        rx = re.compile("(?P<label>([a-zA-Z0-9_]+([ ]+[a-zA-Z0-9_]+)?))\s*:\s*(?P<value>.*)")
        for line in data.splitlines():
            m = rx.match(line)
            if m:
                l = m.group("label")
                v = m.group("value")
                info[l] = v

    def parse_sysctl(self, info, output):
        rx = re.compile("(?P<label>[a-zA-Z0-9_.]+)\s*=\s*(?P<value>.*)")
        for line in output.splitlines():
            m = rx.match(line)
            if m:
                l = m.group("label")
                v = m.group("value")
                info[l] = v

    
    def machine_info(self):
        info = {}
        
        # kernel config
        kconfig_path = "/proc/config.gz"
        if not os.path.isfile(kconfig_path) and \
            not self._tried_modprobe_configs:
            p = Popen(["modprobe", "configs"], stderr=PIPE)
            p.wait()
            self._tried_modprobe_configs = True
        
        if os.path.isfile(kconfig_path):
            output = check_output(["zcat", kconfig_path])
            self.parse_kconfig(info, output)
        else:
            uname = check_output(["uname", "-r"])
            kconfig_path = "/boot/config-%s" % uname.strip()
            if os.path.isfile(kconfig_path):
                with open(kconfig_path, "r") as f:
                    self.parse_kconfig(info, f.read())
        
        cpuinfo = "/proc/cpuinfo"
        if os.path.isfile(cpuinfo):
            with open(cpuinfo, "r") as f:
                self.parse_cpuinfo(info, f.read())
        
        
        bootid = "/proc/sys/kernel/random/boot_id"
        if os.path.isfile(bootid):
            with open(bootid, "r") as f:
                info["bootid"] = f.read().strip()
        
        # use sysctl -a instead of --all, the later is not supported by busybox
        output = check_output(["sysctl", "-a"], stderr=PIPE)
        self.parse_sysctl(info, output)
        
        cmdline = "/proc/cmdline"
        if os.path.isfile(cmdline):
            with open(cmdline, "r") as f:
                info["cmdline"] = f.read().strip()
        
        return info

class CPUGovernor(object):
    def __init__(self):
        self.state = {}
        self.num_cpus = None

    def get_num_cpus(self):
        if not self.num_cpus:
            low = high = 0
            with open("/sys/devices/system/cpu/online", "r") as f:
                low, high = f.read().strip().split("-")
                self.num_cpus = int(high)
        return self.num_cpus

    def _set_governor(self, cpu, name):
        cpufile = "/sys/devices/system/cpu/cpu{}/cpufreq/scaling_governor".format(cpu)
        temp = "powersave"
        with open(cpufile, "r") as governor:
            temp = governor.read().strip()
            
        with open(cpufile, "w") as governor:
            governor.write(name)
        return temp

    def set_governor(self, name):
        cpus = self.get_num_cpus()
        for cpu in range(cpus + 1):
            self.state[cpu] = self._set_governor(cpu, name)
            
    def restore(self):
        for cpu, gov in self.state.items():
            self._set_governor(cpu, gov)

if __name__=="__main__":

    commands = {
        "experiments": ExperimentCommand()
    }

    import argparse
    
    parser = argparse.ArgumentParser()

    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        action="store_true")

    subparsers = parser.add_subparsers(help='sub-command help', dest="cmd")
    for name, command in commands.items():
        sub = subparsers.add_parser(name)
        command.setup_arguments(sub)

    args = parser.parse_args()

    obj = commands[args.cmd]
    
    try:
        obj.run(args)
    except KeyboardInterrupt:
        print("exiting...")
    except Exception as e:
        print(e)
    finally:
        obj.cleanup()

